<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sorteo en Vivo</title>

    <style>
      :root {
        --bg: #0a0a14;
        --bg2: #1a1f3a;
        --card: #1e2347;
        --txt: #f5f5f5;
        --muted: #c0c0c0;
        --ok: #22c55e;
        --warn: #FFD700;
        --danger: #DC143C;
        --accent: #0047AB;
        --neon: #FFD700;
        --neon2: #DC143C;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        height: 100%;
        font-family: Segoe UI, Tahoma, sans-serif;
        background: radial-gradient(circle at 20% 0, #1e3a8a, #0a0a14 55%);
        color: var(--txt);
      }

      body::before {
        content: "";
        position: fixed;
        inset: -10% -10%;
        z-index: -2;
        background:
          radial-gradient(60% 50% at 20% 10%, rgba(255, 215, 0, 0.18), transparent 60%),
          radial-gradient(60% 50% at 80% 20%, rgba(220, 20, 60, 0.16), transparent 60%),
          radial-gradient(70% 60% at 50% 90%, rgba(0, 71, 171, 0.12), transparent 65%);
        filter: blur(20px);
        animation: aurora 12s ease-in-out infinite alternate;
      }

      body::after {
        content: "";
        position: fixed;
        inset: 0;
        z-index: -3;
        background: linear-gradient(120deg, rgba(10, 10, 20, 0.9), rgba(5, 5, 10, 0.95));
      }

      @keyframes aurora {
        0% {
          transform: translateY(-2%) translateX(-1%) scale(1);
        }
        50% {
          transform: translateY(1%) translateX(1%) scale(1.02);
        }
        100% {
          transform: translateY(2%) translateX(2%) scale(1.04);
        }
      }

      .app {
        max-width: 1300px;
        margin: 0 auto;
        padding: 14px;
      }

      .top {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-bottom: 12px;
      }

      .btn {
        border: 0;
        border-radius: 10px;
        padding: 10px 14px;
        background: #1e3a8a;
        color: #fff;
        font-weight: 700;
        cursor: pointer;
      }

      .btn:hover {
        opacity: 0.93;
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .btn.primary {
        background: linear-gradient(90deg, #DAA520, #FFD700);
        color: #1a1a1a;
      }

      .btn.warn {
        background: #b8860b;
      }

      .btn.danger {
        background: #b91c1c;
      }

      .pill {
        background: #1a1f3a;
        border: 1px solid #0047AB;
        padding: 7px 10px;
        border-radius: 999px;
        font-size: 0.9rem;
      }

      /* Pill m√°s grande en modo proyecci√≥n */
      #projectionView .pill {
        font-size: clamp(0.85rem, 1.3vw, 1.05rem);
        padding: 8px 14px;
        font-weight: 700;
      }

      /* Bot√≥n pantalla completa */
      .fullscreen-btn {
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 1000;
        background: rgba(26, 31, 58, 0.9);
        border: 2px solid rgba(255, 215, 0, 0.4);
        border-radius: 8px;
        padding: 8px 12px;
        color: #FFD700;
        cursor: pointer;
        font-size: 1.2rem;
        transition: all 0.3s;
        backdrop-filter: blur(10px);
      }

      .fullscreen-btn:hover {
        background: rgba(26, 31, 58, 1);
        border-color: rgba(255, 215, 0, 0.7);
        transform: scale(1.05);
      }

      .fullscreen-hint {
        position: fixed;
        bottom: 10px;
        right: 10px;
        z-index: 1000;
        background: rgba(26, 31, 58, 0.8);
        border: 1px solid rgba(255, 215, 0, 0.3);
        border-radius: 6px;
        padding: 6px 10px;
        color: #FFD700;
        font-size: 0.8rem;
        opacity: 0.7;
      }

      .grid {
        display: grid;
        gap: 12px;
      }

      .layout {
        grid-template-columns: 380px 1fr;
      }

      @media (max-width: 960px) {
        .layout {
          grid-template-columns: 1fr;
        }
      }

      .card {
        background: linear-gradient(180deg, rgba(30, 35, 71, 0.78), rgba(26, 31, 58, 0.78));
        border: 1px solid rgba(255, 215, 0, 0.25);
        border-radius: 14px;
        padding: 14px;
        backdrop-filter: blur(10px);
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.08);
      }

      h1,
      h2,
      h3,
      p {
        margin: 0;
      }

      h1 {
        font-size: 1.4rem;
      }

      h2 {
        font-size: 1.12rem;
      }

      .muted {
        color: var(--muted);
      }

      .stack {
        display: grid;
        gap: 10px;
      }

      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }

      label {
        font-size: 0.9rem;
        color: #e5e5e5;
      }

      input,
      select {
        width: 100%;
        padding: 10px;
        border-radius: 10px;
        border: 1px solid #0047AB;
        background: #0f0f1a;
        color: #fff;
      }

      .status.ok {
        color: var(--ok);
      }

      .status.closed {
        color: var(--danger);
      }

      .counter {
        font-size: 2rem;
        font-weight: 900;
        color: var(--warn);
      }

      .small {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .msg {
        padding: 8px;
        border-radius: 8px;
        font-size: 0.88rem;
      }

      .msg.error {
        background: #4a0e0e;
        color: #ffc9c9;
      }

      .msg.ok {
        background: #1f4d39;
        color: #d5ffe0;
      }

      .tbl {
        max-height: 66vh;
        overflow: auto;
        border-radius: 10px;
        border: 1px solid #0047AB;
      }

      table {
        width: 100%;
        border-collapse: collapse;
      }

      th,
      td {
        padding: 8px;
        border-bottom: 1px solid #1e3a8a;
        text-align: left;
      }

      th {
        position: sticky;
        top: 0;
        background: #1a2957;
      }

      .hidden {
        display: none !important;
      }

      .proj {
        min-height: calc(100vh - 70px);
        display: grid;
        place-items: center;
        text-align: center;
        background:
          radial-gradient(600px 280px at 10% 10%, rgba(255, 215, 0, 0.22), transparent 65%),
          radial-gradient(700px 300px at 90% 90%, rgba(220, 20, 60, 0.22), transparent 65%),
          #070f1a;
        border-radius: 16px;
        border: 1px solid #0047AB;
        position: relative;
        overflow: hidden;
      }

      .proj.glass {
        background: linear-gradient(180deg, rgba(10, 10, 20, 0.78), rgba(10, 10, 20, 0.9));
        backdrop-filter: blur(12px);
      }

      .proj.hype {
        animation: hype 1.2s ease-in-out 1;
      }

      @keyframes hype {
        0% {
          transform: scale(1);
          filter: blur(0);
        }
        30% {
          transform: scale(1.01) translateY(-2px);
          filter: blur(0.5px);
        }
        60% {
          transform: scale(1.005) translateY(1px);
          filter: blur(0);
        }
        100% {
          transform: scale(1);
        }
      }

      .proj-box {
        width: min(1200px, 96vw);
        padding: 8px 18px;
      }

      .title {
        font-size: clamp(1rem, 1.6vw, 1.35rem);
        font-weight: 700;
        opacity: 0.85;
        margin-bottom: 6px;
      }

      .meta {
        font-size: clamp(0.85rem, 1.3vw, 1.1rem);
        color: #c0c0c0;
        margin-top: 3px;
        opacity: 0.7;
      }

      .prize {
        font-size: clamp(1.1rem, 1.8vw, 1.5rem);
        color: #FFD700;
        font-weight: 900;
        margin-top: 6px;
        margin-bottom: 10px;
        text-shadow: 0 0 40px rgba(255, 215, 0, 0.8), 0 0 80px rgba(255, 215, 0, 0.4);
        animation: prizeGlow 3s ease-in-out infinite;
        line-height: 1.1;
        padding: 8px 14px;
        background: rgba(255, 215, 0, 0.1);
        border-radius: 10px;
        border: 2px solid rgba(255, 215, 0, 0.3);
      }

      @keyframes prizeGlow {
        0%,
        100% {
          text-shadow: 0 0 30px rgba(255, 215, 0, 0.6), 0 0 60px rgba(255, 215, 0, 0.3);
        }
        50% {
          text-shadow: 0 0 40px rgba(255, 215, 0, 0.9), 0 0 80px rgba(255, 215, 0, 0.5);
        }
      }

      .grid-container {
        position: relative;
        margin: 8px auto;
        max-width: min(1100px, 96vw);
        padding: 14px;
        background: linear-gradient(135deg, rgba(26, 31, 58, 0.6), rgba(30, 35, 71, 0.6));
        border: 2px solid rgba(255, 215, 0, 0.3);
        border-radius: 14px;
        backdrop-filter: blur(10px);
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      }

      .participants-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 12px;
        position: relative;
      }

      .participant-box {
        position: relative;
        padding: 16px 12px;
        border-radius: 12px;
        font-weight: 700;
        font-size: clamp(1rem, 1.6vw, 1.35rem);
        color: #fff;
        text-align: center;
        border: 3px solid transparent;
        transition: all 0.15s;
        cursor: default;
        text-shadow: 0 2px 8px rgba(0, 0, 0, 0.9);
        min-height: 75px;
        display: flex;
        align-items: center;
        justify-content: center;
        word-break: break-word;
        overflow: hidden;
      }

      .participant-box.color-1 {
        background: linear-gradient(135deg, #1e3a8a, #162d6f);
      }
      .participant-box.color-2 {
        background: linear-gradient(135deg, #2563eb, #1d4ed8);
      }
      .participant-box.color-3 {
        background: linear-gradient(135deg, #1d4ed8, #1e40af);
      }
      .participant-box.color-4 {
        background: linear-gradient(135deg, #0047AB, #003580);
      }
      .participant-box.color-5 {
        background: linear-gradient(135deg, #1e40af, #1e3a8a);
      }
      .participant-box.color-6 {
        background: linear-gradient(135deg, #1a2c5b, #0f1b3a);
      }

      .participant-box.active {
        border-color: #FFD700;
        box-shadow: 0 0 30px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255, 215, 0, 0.3);
        transform: scale(1.05);
        animation: pulseActive 0.3s ease-in-out;
        z-index: 10;
      }

      @keyframes pulseActive {
        0%,
        100% {
          transform: scale(1.05);
        }
        50% {
          transform: scale(1.08);
        }
      }

      .participant-box.winner {
        border-color: #FFD700;
        background: linear-gradient(135deg, #FFD700, #DAA520);
        box-shadow: 0 0 50px rgba(255, 215, 0, 1), inset 0 0 30px rgba(255, 255, 255, 0.3);
        transform: scale(1.1);
        animation: winnerPulse 1s ease-in-out infinite;
        z-index: 20;
      }

      @keyframes winnerPulse {
        0%,
        100% {
          box-shadow: 0 0 50px rgba(255, 215, 0, 1), inset 0 0 30px rgba(255, 255, 255, 0.3);
        }
        50% {
          box-shadow: 0 0 70px rgba(255, 215, 0, 1), 0 0 90px rgba(255, 215, 0, 0.6),
            inset 0 0 40px rgba(255, 255, 255, 0.4);
        }
      }

      .particles-canvas {
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: 1;
      }

      .winner {
        background: linear-gradient(135deg, rgba(26, 31, 58, 0.95), rgba(30, 35, 71, 0.95));
        border: 2px solid rgba(255, 215, 0, 0.5);
        border-radius: 12px;
        padding: 12px;
        min-height: 60px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 30px rgba(255, 215, 0, 0.2);
        backdrop-filter: blur(10px);
        margin-top: 10px;
        position: relative;
        overflow: hidden;
      }

      .winner-main {
        font-size: clamp(0.95rem, 1.5vw, 1.25rem);
        line-height: 1.4;
      }

      .winner.celebrating {
        animation: celebrate 0.6s ease-in-out;
      }

      @keyframes celebrate {
        0%,
        100% {
          transform: scale(1);
        }
        25% {
          transform: scale(1.02) rotate(1deg);
        }
        50% {
          transform: scale(1.04) rotate(-1deg);
        }
        75% {
          transform: scale(1.02) rotate(0.5deg);
        }
      }

      .actions {
        margin-top: 12px;
        display: flex;
        gap: 8px;
        justify-content: center;
        flex-wrap: wrap;
      }

      .actions .btn.primary {
        font-size: clamp(1rem, 1.6vw, 1.35rem);
        padding: 12px 32px;
        min-width: 220px;
        font-weight: 900;
        box-shadow: 0 6px 20px rgba(255, 215, 0, 0.5);
        transition: all 0.3s;
      }

      .actions .btn.primary:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 6px 25px rgba(255, 215, 0, 0.6);
      }

      .actions .btn.primary:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .winners-list {
        margin-top: 10px;
        text-align: left;
        background: rgba(14, 36, 59, 0.6);
        border: 1px solid rgba(53, 87, 122, 0.5);
        border-radius: 8px;
        padding: 10px;
        backdrop-filter: blur(8px);
      }

      .winners-list h3 {
        margin: 0 0 6px 0;
        font-size: clamp(0.95rem, 1.5vw, 1.2rem);
        color: #FFD700;
      }

      .winners-list ul {
        margin: 0;
        padding-left: 18px;
        font-size: clamp(0.85rem, 1.3vw, 1.05rem);
        line-height: 1.5;
      }

      .winners-list li {
        margin: 5px 0;
        color: #e5e5e5;
      }

      .history {
        display: grid;
        gap: 7px;
      }

      .history div {
        padding: 8px;
        border-radius: 8px;
        border: 1px solid #1e3a8a;
        background: #0f1524;
      }

      /* Overlay - estructura exacta del codigo funcional */
      .reveal-overlay {
        position: absolute;
        inset: 0;
        background: radial-gradient(1200px 600px at 50% 20%, rgba(255, 215, 0, 0.22), rgba(0, 0, 0, 0.78));
        display: none;
        z-index: 100;
      }

      .reveal-overlay.show {
        display: grid;
      }

      .reveal-inner {
        display: grid;
        place-items: center;
        padding: 24px;
      }

      .reveal-card {
        background: linear-gradient(135deg, #FFD700, #DAA520);
        padding: 40px 60px;
        border-radius: 20px;
        font-size: clamp(2rem, 5vw, 4rem);
        font-weight: 900;
        color: #1a1a1a;
        text-shadow: 0 4px 20px rgba(0, 0, 0, 0.7), 0 0 40px rgba(255, 255, 255, 0.3);
        box-shadow: 0 25px 80px rgba(255, 215, 0, 0.8), 0 0 120px rgba(255, 215, 0, 0.5),
          inset 0 0 40px rgba(255, 255, 255, 0.2);
        transform: scale(0.5);
        animation: revealPop 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
        border: 3px solid rgba(255, 255, 255, 0.4);
        position: relative;
      }

      @keyframes revealPop {
        0% {
          transform: scale(0.5) rotate(-8deg);
          opacity: 0;
        }
        60% {
          transform: scale(1.15) rotate(3deg);
        }
        80% {
          transform: scale(0.95) rotate(-1deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
          opacity: 1;
        }
      }

      /* Canvas confetti */
      #confetti {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }
    </style>
  </head>

  <body>
    <div class="app">
      <div class="top">
        <button class="btn" id="goOperator">Modo Operador</button>
        <button class="btn" id="goProjection">Modo Proyeccion</button>
        <span class="pill">Offline tras carga: SI</span>
        <span class="pill">Sorteos guardados: <b id="drawCount">0</b></span>
      </div>

      <section id="operatorView">
        <div class="grid layout">
          <div class="card stack">
            <h1>Registro / Control</h1>
            <p class="small">Operador: configura, registra participantes y cierra el registro.</p>

            <div class="stack">
              <h2>Configuracion</h2>
              <label>Titulo (opcional)</label>
              <input id="drawTitle" maxlength="100" placeholder="Ej. Sorteo de Aniversario" />
              <label>Hora del sorteo (HH:MM)</label>
              <input id="drawTime" type="time" />
              <button class="btn" id="saveConfig">Guardar configuracion</button>
              <div id="cfgMsg" class="small"></div>
            </div>

            <div class="stack">
              <h2>Nuevo participante</h2>
              <label>Nombre *</label>
              <input id="name" maxlength="120" list="knownNames" />
              <datalist id="knownNames"></datalist>
              <button class="btn primary" id="register">Registrar</button>
              <div id="regMsg" class="small">Tip: puedes presionar ENTER para registrar rapido.</div>
            </div>

            <div class="stack">
              <h2>Correccion de nombre</h2>
              <div class="row">
                <div>
                  <label>Participante</label>
                  <select id="editParticipant"></select>
                </div>
                <div>
                  <label>Nombre corregido</label>
                  <input id="editName" maxlength="120" placeholder="Nuevo nombre" />
                </div>
              </div>
              <button class="btn" id="applyNameFix">Aplicar correccion</button>
              <div id="editMsg" class="small"></div>
            </div>

            <div class="stack">
              <h2>Estado</h2>
              <div class="counter" id="total">0</div>
              <div class="small">Total registrados</div>
              <div id="countdown">Configura hora del sorteo.</div>
              <div id="regStatus" class="status ok">Registro abierto</div>
              <button class="btn danger" id="closeNow">Cerrar registro ahora</button>

              <div class="row">
                <div>
                  <label>Valor del premio</label>
                  <input id="prize" maxlength="80" disabled />
                </div>
                <div style="display: flex; align-items: end">
                  <button class="btn primary" id="toProjection" disabled style="width: 100%">
                    Ir a pantalla del sorteo
                  </button>
                </div>
              </div>
            </div>

            <div class="stack">
              <h2>Historial / Exportar</h2>
              <div class="row">
                <button class="btn" id="exportJson">JSON</button>
                <button class="btn" id="exportCsv">CSV</button>
              </div>
              <button class="btn danger" id="clearData">Borrar datos previos</button>
              <div id="history" class="history"></div>
            </div>

            <div class="small">
              <b>Instrucciones rapidas</b><br />
              - Operador: registra y controla.<br />
              - Proyeccion: inicia el sorteo para pantalla grande.
            </div>
          </div>

          <div class="card stack">
            <h2>Listado en orden exacto de registro</h2>
            <div class="tbl">
              <table>
                <thead>
                  <tr>
                    <th>#</th>
                    <th>Nombre</th>
                    <th>Hora</th>
                    <th>Acciones</th>
                  </tr>
                </thead>
                <tbody id="participantsBody"></tbody>
              </table>
            </div>
          </div>
        </div>
      </section>

      <section id="projectionView" class="hidden">
        <button class="fullscreen-btn" id="fullscreenBtn" title="Pantalla completa (F11 o doble clic)">‚õ∂</button>
        <div class="fullscreen-hint">Presiona ESC para salir de pantalla completa</div>
        <div class="proj glass" id="projectionShell">
          <!-- Overlay revelado -->
          <div class="reveal-overlay" id="revealOverlay">
            <canvas id="confetti"></canvas>
            <div class="reveal-inner">
              <div class="reveal-card" id="revealCard">¬°Ganador revelado!</div>
            </div>
          </div>

          <div class="proj-box">
            <div id="pTitle" class="title">Sorteo en Vivo</div>
            <div id="pPrize" class="prize">Premio: --</div>

            <div class="grid-container">
              <canvas class="particles-canvas" id="particlesCanvas"></canvas>
              <div class="participants-grid" id="participantsGrid"></div>
            </div>

            <div class="actions">
              <button class="btn primary" id="start">INICIAR SORTEO</button>
            </div>

            <div id="winner" class="winner">
              <div id="winnerMain" class="winner-main">Pulsa INICIAR SORTEO para comenzar</div>

              <div class="winners-list">
                <h3>üèÜ Ganadores de este sorteo</h3>
                <ul id="sessionWinners">
                  <li style="opacity: 0.6; font-style: italic">A√∫n no hay ganadores</li>
                </ul>
              </div>
            </div>

            <div style="margin-top: 20px; display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; opacity: 0.7">
              <button class="btn hidden" id="savePrepare">Finalizar sorteo</button>
              <span id="countStatus" class="pill" style="display: inline-block; padding: 8px 14px">
                Participantes: 0
              </span>
            </div>
          </div>
        </div>
      </section>
    </div>

    <script>
      // ==========================================================
      //  APP: SORTEO EN VIVO (IndexedDB + Proyecci√≥n + Confetti)
      // ==========================================================

      const DB_NAME = "live_raffle_db";
      const DB_VERSION = 2;

      const S = {
        P: "participants",
        D: "draws",
        C: "config",
        K: "knownClients",
      };

      const state = {
        participants: [],
        draws: [],
        knownClients: [],
        config: {
          title: "",
          time: "",
          closed: false,
          closedAt: null,
          prize: "",
          excludeWinners: true,
          sessionDrawIds: [],
        },
        spinning: false,
        soundOn: true,
      };

      const $ = (id) => document.getElementById(id);
      const pad = (n) => String(n).padStart(2, "0");

      let db;

      function nowISO() {
        return new Date().toISOString();
      }

      function fmtTime(d) {
        return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
      }

      function fmtLong(d) {
        const day = ["domingo", "lunes", "martes", "miercoles", "jueves", "viernes", "sabado"][d.getDay()];
        const month = [
          "enero",
          "febrero",
          "marzo",
          "abril",
          "mayo",
          "junio",
          "julio",
          "agosto",
          "septiembre",
          "octubre",
          "noviembre",
          "diciembre",
        ][d.getMonth()];

        return `${day} ${d.getDate()} de ${month} de ${d.getFullYear()}`;
      }

      function safeText(v) {
        return String(v || "").replace(/[&<>"']/g, (m) => {
          return { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[m];
        });
      }

      function norm(v) {
        return (v || "").trim().toLowerCase().replace(/\s+/g, " ");
      }

      function formatPrize(value) {
        if (!value) return "";

        // Extraer n√∫meros del valor
        const numbers = value.replace(/[^\d]/g, "");

        if (!numbers) return value; // Si no hay n√∫meros, devolver el original

        // Formatear con puntos como separadores de miles
        const formatted = numbers.replace(/\B(?=(\d{3})+(?!\d))/g, ".");

        // Si el valor original no ten√≠a s√≠mbolo $, agregarlo
        if (!value.includes("$")) {
          return "$" + formatted;
        }

        return "$" + formatted;
      }

      function secureIndex(max) {
        const buf = new Uint32Array(1);
        const limit = 0xffffffff - (0xffffffff % max);
        let x;

        do {
          crypto.getRandomValues(buf);
          x = buf[0];
        } while (x >= limit);

        return x % max;
      }

      function beep(freq = 880, dur = 0.06, gain = 0.05) {
        if (!state.soundOn) return;

        try {
          const ctx = beep.ctx || (beep.ctx = new (window.AudioContext || window.webkitAudioContext)());
          const o = ctx.createOscillator();
          const g = ctx.createGain();

          o.type = "sine";
          o.frequency.value = freq;

          g.gain.value = gain;

          o.connect(g);
          g.connect(ctx.destination);

          o.start();
          o.stop(ctx.currentTime + dur);
        } catch (e) {
          // Silenciar errores de audio para no interrumpir la animaci√≥n
          console.warn("Error de audio:", e);
        }
      }

      function ding() {
        beep(880, 0.09, 0.06);
        setTimeout(() => beep(1320, 0.12, 0.05), 80);
      }

      function openDB() {
        return new Promise((resolve, reject) => {
          const req = indexedDB.open(DB_NAME, DB_VERSION);

          req.onupgradeneeded = () => {
            const d = req.result;

            if (!d.objectStoreNames.contains(S.P)) d.createObjectStore(S.P, { keyPath: "id", autoIncrement: true });
            if (!d.objectStoreNames.contains(S.D)) d.createObjectStore(S.D, { keyPath: "id", autoIncrement: true });
            if (!d.objectStoreNames.contains(S.C)) d.createObjectStore(S.C, { keyPath: "key" });
            if (!d.objectStoreNames.contains(S.K)) d.createObjectStore(S.K, { keyPath: "key" });
          };

          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
      }

      function reqP(req) {
        return new Promise((res, rej) => {
          req.onsuccess = () => res(req.result);
          req.onerror = () => rej(req.error);
        });
      }

      function os(name, mode = "readonly") {
        return db.transaction(name, mode).objectStore(name);
      }

      async function saveConfig() {
        await reqP(os(S.C, "readwrite").put({ key: "app", value: state.config }));
      }

      function todayAt(hhmm) {
        if (!hhmm) return null;

        const [h, m] = hhmm.split(":").map(Number);
        const d = new Date();

        d.setHours(h, m, 0, 0);
        return d;
      }

      function closedByTime() {
        const t = todayAt(state.config.time);
        return t ? new Date() >= t : false;
      }

      async function load() {
        try {
          state.participants = (await reqP(os(S.P).getAll())).sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
          state.draws = (await reqP(os(S.D).getAll())).sort((a, b) => new Date(b.drawAt) - new Date(a.drawAt));
          state.knownClients = (await reqP(os(S.K).getAll())).sort((a, b) => a.name.localeCompare(b.name));

          const c = await reqP(os(S.C).get("app"));
          if (c && c.value) {
            // Fusionar configuraci√≥n guardada con valores predeterminados
            state.config = {
              title: c.value.title || "",
              time: c.value.time || "",
              closed: c.value.closed || false,
              closedAt: c.value.closedAt || null,
              prize: c.value.prize || "",
              excludeWinners: c.value.excludeWinners !== false,
              sessionDrawIds: Array.isArray(c.value.sessionDrawIds) ? c.value.sessionDrawIds : [],
            };
          }

          if (!state.config.closed && closedByTime()) {
            state.config.closed = true;
            state.config.closedAt = nowISO();
            await saveConfig();
          }
        } catch (error) {
          console.error("Error cargando datos:", error);
          // Si hay error, usar estado limpio predeterminado
          state.participants = [];
          state.draws = [];
          state.knownClients = [];
          state.config = {
            title: "",
            time: "",
            closed: false,
            closedAt: null,
            prize: "",
            excludeWinners: true,
            sessionDrawIds: [],
          };
          await saveConfig();
        }
      }

      function showMsg(id, text, type) {
        const el = $(id);
        if (!el) return;

        el.className = type ? `msg ${type}` : "small";
        el.textContent = text || "";
      }

      function renderParticipants() {
        const body = $("participantsBody");
        body.innerHTML = "";

        const isClosed = state.config.closed || closedByTime();

        state.participants.forEach((p, i) => {
          const tr = document.createElement("tr");
          const t = new Date(p.createdAt);

          const deleteBtn = isClosed
            ? '<span style="opacity:0.4;font-size:0.8rem">Cerrado</span>'
            : `<button class="btn danger" style="font-size:0.75rem;padding:4px 8px" onclick="deleteParticipant(${p.id})">Eliminar</button>`;

          tr.innerHTML = `<td>${i + 1}</td><td>${safeText(p.name)}</td><td>${fmtTime(t)}</td><td>${deleteBtn}</td>`;
          body.appendChild(tr);
        });

        $("total").textContent = state.participants.length;
        renderEditOptions();
      }

      function renderEditOptions() {
        const sel = $("editParticipant");
        sel.innerHTML = "";

        const empty = document.createElement("option");
        empty.value = "";
        empty.textContent = state.participants.length ? "Selecciona participante" : "Sin participantes";
        sel.appendChild(empty);

        state.participants.forEach((p, i) => {
          const op = document.createElement("option");
          op.value = String(p.id);
          op.textContent = `${i + 1}. ${p.name}`;
          sel.appendChild(op);
        });
      }

      function renderKnownClients() {
        const dl = $("knownNames");
        dl.innerHTML = "";

        state.knownClients.forEach((c) => {
          const op = document.createElement("option");
          op.value = c.name;
          dl.appendChild(op);
        });
      }

      function fmtPayment(d) {
        const months = ["ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic"];
        const day = pad(d.getDate());
        const month = months[d.getMonth()];
        const year = d.getFullYear();

        let hour = d.getHours();
        const min = pad(d.getMinutes());
        const ampm = hour >= 12 ? "pm" : "am";
        hour = hour % 12 || 12;

        return `${day}-${month}-${year} ${hour}:${min} ${ampm}`;
      }

      function renderHistory() {
        const h = $("history");
        h.innerHTML = "";

        state.draws.slice(0, 20).forEach((d) => {
          const div = document.createElement("div");

          const paidStatus = d.paid
            ? `<span style="color:var(--ok);font-weight:700">‚úì PAGADO</span> <span style="opacity:0.7">(${fmtPayment(
                new Date(d.paidAt)
              )})</span>`
            : `<span style="color:var(--danger);font-weight:700">‚è≥ PENDIENTE</span>`;

          const paidBtn = d.paid
            ? ""
            : `<button class="btn" style="font-size:0.8rem;padding:5px 10px;margin-top:5px" onclick="registerPayment(${d.id})">Registrar pago</button>`;

          div.innerHTML = `
            <b>${safeText(d.winnerName)}</b> - ${safeText(d.prize || "Sin premio")}<br>
            <span class="small">
              ${fmtLong(new Date(d.drawAt))} ${d.time} | cierre: ${d.closedAt ? new Date(d.closedAt).toLocaleString() : "n/d"}
            </span><br>
            <div style="margin-top:6px">${paidStatus}${paidBtn}</div>
          `;

          h.appendChild(div);
        });

        $("drawCount").textContent = state.draws.length;
      }

      function setIfNotEditing(id, value) {
        const el = $(id);
        if (document.activeElement !== el) el.value = value;
      }

      function updateProjectionStatus() {
        const count = $("countStatus");
        count.textContent = `Participantes: ${state.participants.length}`;
      }

      function renderConfig() {
        setIfNotEditing("drawTitle", state.config.title || "");
        setIfNotEditing("drawTime", state.config.time || "");

        $("prize").value = state.config.prize || "";

        const isClosed = state.config.closed || closedByTime();
        if (isClosed && !state.config.closed) state.config.closed = true;

        $("regStatus").textContent = isClosed ? "Registro cerrado" : "Registro abierto";
        $("regStatus").className = `status ${isClosed ? "closed" : "ok"}`;

        ["name", "register", "closeNow", "editParticipant", "editName", "applyNameFix"].forEach((id) => {
          $(id).disabled = isClosed;
        });

        $("prize").disabled = !isClosed;
        $("toProjection").disabled = !isClosed;

        $("pTitle").textContent = state.config.title || "Sorteo en Vivo";
        $("pPrize").textContent = state.config.prize
          ? `Premio: ${formatPrize(state.config.prize)}`
          : "Premio: --";

        updateProjectionStatus();
      }

      function renderCountdown() {
        const lbl = $("countdown");

        if (!state.config.time) {
          lbl.textContent = "Configura hora del sorteo.";
          return;
        }

        const target = todayAt(state.config.time);
        let diff = target - new Date();

        if (diff <= 0) {
          lbl.textContent = "Llego la hora del sorteo.";
          return;
        }

        const h = Math.floor(diff / 3600000);
        diff -= h * 3600000;
        const m = Math.floor(diff / 60000);

        lbl.textContent = `Faltan ${h} horas ${m} minutos para el sorteo`;
      }

      function validateDup({ name, excludeId = null }) {
        const n = norm(name);

        for (const p of state.participants) {
          if (excludeId && p.id === excludeId) continue;
          if (n && n === norm(p.name)) return "Nombre duplicado en el registro actual.";
        }

        return "";
      }

      async function rememberKnownClient(name) {
        const clean = name.trim();
        if (!clean) return;

        const key = norm(clean);

        await reqP(os(S.K, "readwrite").put({ key, name: clean }));

        const i = state.knownClients.findIndex((c) => c.key === key);
        if (i >= 0) state.knownClients[i].name = clean;
        else state.knownClients.push({ key, name: clean });

        state.knownClients.sort((a, b) => a.name.localeCompare(b.name));
        renderKnownClients();
      }

      function winnerPool() {
        if (!state.config.excludeWinners) return state.participants;

        const winners = new Set(state.draws.map((d) => d.winnerId));
        return state.participants.filter((p) => !winners.has(p.id));
      }

      function getSessionDraws() {
        const ids = state.config.sessionDrawIds || [];
        const byId = new Map(state.draws.map((d) => [d.id, d]));

        return ids.map((id) => byId.get(id)).filter(Boolean);
      }

      function renderSessionWinners() {
        const ul = $("sessionWinners");
        ul.innerHTML = "";

        const draws = getSessionDraws();

        if (!draws.length) {
          ul.innerHTML = '<li style="opacity:0.6;font-style:italic">A√∫n no hay ganadores</li>';
          updateDrawControls();
          return;
        }

        draws.forEach((d, i) => {
          const li = document.createElement("li");
          const emoji = i === 0 ? "ü•á" : i === 1 ? "ü•à" : i === 2 ? "ü•â" : "üèÖ";

          li.innerHTML = `
            <span style="font-size:1.2em">${emoji}</span>
            <b style="color:var(--neon)">${safeText(d.winnerName)}</b>
            <span style="opacity:0.7">‚Üí</span>
            <b style="color:var(--warn)">${safeText(formatPrize(d.prize) || "Sin premio")}</b>
          `;

          li.style.marginBottom = "8px";
          ul.appendChild(li);
        });

        updateDrawControls();
      }

      function fillGrid(pool) {
        const names = pool.length ? pool.map((p) => p.name) : ["Sin participantes"];
        const grid = $("participantsGrid");

        grid.innerHTML = "";

        names.forEach((name, i) => {
          const box = document.createElement("div");
          box.className = `participant-box color-${(i % 6) + 1}`;
          box.textContent = name;
          box.dataset.index = String(i);
          box.dataset.name = name;
          grid.appendChild(box);
        });
      }

      // ===== PARTICLES =====
      let particles = [];

      function initParticles() {
        const canvas = $("particlesCanvas");
        const container = canvas.parentElement;

        canvas.width = container.offsetWidth;
        canvas.height = container.offsetHeight;

        particles = [];
        const particleColors = ['#FFD700', '#DC143C', '#0047AB', '#FFFFFF', '#DAA520'];

        for (let i = 0; i < 30; i++) {
          particles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            vx: (Math.random() - 0.5) * 0.5,
            vy: (Math.random() - 0.5) * 0.5,
            radius: 1 + Math.random() * 2,
            color: particleColors[Math.floor(Math.random() * particleColors.length)],
          });
        }
      }

      function animateParticles() {
        const canvas = $("particlesCanvas");
        const ctx = canvas.getContext("2d");

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        particles.forEach((p) => {
          p.x += p.vx;
          p.y += p.vy;

          if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
          if (p.y < 0 || p.y > canvas.height) p.vy *= -1;

          ctx.fillStyle = p.color + '99';
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
          ctx.fill();
        });

        requestAnimationFrame(animateParticles);
      }

      // ===== ANIMACI√ìN SELECCI√ìN =====
      function animateSelection(targetName, duration) {
        return new Promise((resolve, reject) => {
          try {
            const boxes = [...$("participantsGrid").children];
            const targetBox = boxes.find((box) => box.dataset.name === targetName);

            if (!targetBox) {
              resolve();
              return;
            }

            const startTime = performance.now();
            let lastIndex = -1;
            let currentIndex = 0;
            let animationId = null;

            function animate(currentTime) {
              try {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const speed = Math.max(30, 500 * progress);

                if (currentTime - animate.lastTick > speed) {
                  animate.lastTick = currentTime;

                  if (lastIndex >= 0 && boxes[lastIndex]) {
                    boxes[lastIndex].classList.remove("active");
                  }

                  if (progress < 0.95) {
                    currentIndex = secureIndex(boxes.length);
                  } else {
                    currentIndex = boxes.indexOf(targetBox);
                  }

                  if (boxes[currentIndex]) {
                    boxes[currentIndex].classList.add("active");
                    lastIndex = currentIndex;
                  }

                  beep(500 + progress * 800, 0.03, 0.04);
                }

                if (progress < 1) {
                  animationId = requestAnimationFrame(animate);
                } else {
                  boxes.forEach((box) => box.classList.remove("active"));
                  if (targetBox) targetBox.classList.add("winner");
                  ding();
                  resolve();
                }
              } catch (error) {
                console.error("Error en animaci√≥n:", error);
                if (animationId) cancelAnimationFrame(animationId);
                reject(error);
              }
            }

            animate.lastTick = startTime;
            animationId = requestAnimationFrame(animate);
          } catch (error) {
            console.error("Error iniciando animaci√≥n:", error);
            reject(error);
          }
        });
      }

      // ===== REGISTRO =====
      async function registerParticipant() {
        if (state.config.closed || closedByTime()) {
          showMsg("regMsg", "El registro esta cerrado.", "error");
          return;
        }

        const name = $("name").value.trim();
        if (!name) {
          showMsg("regMsg", "Nombre obligatorio.", "error");
          return;
        }

        const dup = validateDup({ name });
        if (dup) {
          showMsg("regMsg", dup, "error");
          return;
        }

        const p = { name, createdAt: nowISO() };
        p.id = await reqP(os(S.P, "readwrite").add(p));

        await rememberKnownClient(name);

        state.participants.push(p);
        state.participants.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));

        renderParticipants();
        fillGrid(winnerPool());

        showMsg("regMsg", "Participante registrado.", "ok");

        $("name").value = "";
        $("name").focus();
      }

      async function applyNameCorrection() {
        if (state.config.closed || closedByTime()) {
          showMsg("editMsg", "Solo puedes corregir antes de cerrar.", "error");
          return;
        }

        const id = Number($("editParticipant").value);
        const newName = $("editName").value.trim();

        if (!id) {
          showMsg("editMsg", "Selecciona un participante.", "error");
          return;
        }

        if (!newName) {
          showMsg("editMsg", "Ingresa el nombre corregido.", "error");
          return;
        }

        const dup = validateDup({ name: newName, excludeId: id });
        if (dup) {
          showMsg("editMsg", dup, "error");
          return;
        }

        const p = state.participants.find((x) => x.id === id);
        if (!p) {
          showMsg("editMsg", "Participante no encontrado.", "error");
          return;
        }

        p.name = newName;
        await reqP(os(S.P, "readwrite").put(p));

        await rememberKnownClient(newName);

        state.participants.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));

        renderParticipants();
        fillGrid(winnerPool());

        $("editName").value = "";
        showMsg("editMsg", "Nombre corregido correctamente.", "ok");
      }

      async function deleteParticipant(id) {
        if (state.config.closed || closedByTime()) {
          alert("No se puede eliminar participantes con el registro cerrado.");
          return;
        }

        const p = state.participants.find((x) => x.id === id);
        if (!p) {
          alert("Participante no encontrado.");
          return;
        }

        // Verificar si el participante ya gan√≥ un sorteo
        const hasWon = state.draws.some((d) => d.winnerId === id);
        if (hasWon) {
          alert(`No se puede eliminar a "${p.name}" porque ya ha ganado un sorteo.\n\nSi necesitas eliminarlo, primero usa "Borrar datos previos" para limpiar el historial.`);
          return;
        }

        const pass = prompt(`¬øEliminar a "${p.name}"?\n\nIngresa la contrase√±a para confirmar:`);
        if (pass !== "1980") {
          if (pass !== null) alert("Contrase√±a incorrecta.");
          return;
        }

        if (!confirm(`¬øConfirmas eliminar a "${p.name}" del registro?`)) return;

        try {
          await reqP(os(S.P, "readwrite").delete(id));

          const index = state.participants.findIndex((x) => x.id === id);
          if (index >= 0) state.participants.splice(index, 1);

          // Verificar si alg√∫n otro participante tiene el mismo nombre
          const nameKey = norm(p.name);
          const otherWithSameName = state.participants.some((x) => norm(x.name) === nameKey);

          // Si nadie m√°s tiene ese nombre, eliminarlo del autocompletado
          if (!otherWithSameName) {
            const knownIndex = state.knownClients.findIndex((c) => c.key === nameKey);
            if (knownIndex >= 0) {
              await reqP(os(S.K, "readwrite").delete(nameKey));
              state.knownClients.splice(knownIndex, 1);
              renderKnownClients();
            }
          }

          renderParticipants();
          fillGrid(winnerPool());
          updateProjectionStatus();

          alert(`"${p.name}" ha sido eliminado del registro${!otherWithSameName ? " y del autocompletado" : ""}.`);
        } catch (error) {
          console.error("Error eliminando participante:", error);
          alert("Error al eliminar el participante: " + error.message);
        }
      }

      async function saveCfg() {
        state.config.title = $("drawTitle").value.trim();
        state.config.time = $("drawTime").value;

        if (closedByTime() && !state.config.closed) {
          state.config.closed = true;
          state.config.closedAt = nowISO();
        }

        await saveConfig();

        renderConfig();
        renderCountdown();
        fillGrid(winnerPool());

        showMsg("cfgMsg", "Configuracion guardada.", "ok");
      }

      async function closeNow() {
        if (!confirm("Seguro que deseas cerrar registro ahora?")) return;

        state.config.closed = true;
        state.config.closedAt = nowISO();

        await saveConfig();

        renderConfig();
        showMsg("regMsg", "Registro cerrado.", "ok");
      }

      // ===== SORTEO =====
      async function startDraw() {
        if (state.spinning) return;

        const done = (state.config.sessionDrawIds || []).length;
        if (done >= 3) {
          updateDrawControls();
          return;
        }

        // Si ya hay sorteos previos y el registro no est√° cerrado, configurar siguiente sorteo
        if (done >= 1 && !state.config.closed && !closedByTime()) {
          const configured = await configureNextDrawForStart();
          if (!configured) {
            updateDrawControls();
            return;
          }
          // IMPORTANTE: Retornar aqu√≠ para que el usuario presione el bot√≥n de nuevo
          $("winnerMain").textContent = "Configuraci√≥n guardada. Presiona INICIAR SORTEO para comenzar.";
          return;
        }

        if (!state.config.closed && !closedByTime()) {
          $("winnerMain").textContent = "Debes cerrar el registro.";
          return;
        }

        const pool = winnerPool();
        if (!pool.length) {
          $("winnerMain").textContent = "No hay participantes disponibles en el pool.";
          return;
        }

        try {
          state.config.prize = $("prize").value.trim();
          await saveConfig();
          renderConfig();

          [...$("participantsGrid").children].forEach((box) => box.classList.remove("active", "winner"));
          fillGrid(pool);

          $("winnerMain").textContent = "Sorteando...";
          state.spinning = true;
          $("start").disabled = true;

          $("projectionShell").classList.add("hype");

          const w = pool[secureIndex(pool.length)];
          const ms = 4000 + secureIndex(2001);

          $("start").textContent = "SORTEANDO...";

          await animateSelection(w.name, ms);

        const dt = new Date();
        const winnerBox = $("winner");
        const winnerEl = $("winnerMain");

        winnerBox.classList.add("celebrating");

        winnerEl.innerHTML = `
          <div style="font-size:1.2em;color:var(--neon);font-weight:900;text-shadow:0 0 30px rgba(255,215,0,0.8);margin-bottom:8px;line-height:1.2">
            ${safeText(w.name)}
          </div>
          <div style="font-size:0.75em;opacity:0.8;margin-bottom:6px">${fmtLong(dt)} - ${fmtTime(dt)}</div>
          <div style="font-size:0.9em;margin-top:6px;color:var(--warn);font-weight:800;background:rgba(255,215,0,0.15);padding:6px 10px;border-radius:6px;border:2px solid rgba(255,215,0,0.3)">Premio: ${safeText(
            formatPrize(state.config.prize) || "Sin especificar"
          )}</div>
        `;

        setTimeout(() => winnerBox.classList.remove("celebrating"), 600);

        revealWinner(w.name, state.config.prize);

        const draw = {
          drawAt: dt.toISOString(),
          time: fmtTime(dt),
          title: state.config.title || "Sorteo en Vivo",
          prize: state.config.prize || "",
          winnerId: w.id,
          winnerName: w.name,
          closedAt: state.config.closedAt || null,
          participantCount: state.participants.length,
          excludeWinners: !!state.config.excludeWinners,
          paid: false,
          paidAt: null,
          audit: {
            closedAt: state.config.closedAt || null,
            drawAt: dt.toISOString(),
          },
        };

        draw.id = await reqP(os(S.D, "readwrite").add(draw));
        state.draws.unshift(draw);

        renderHistory();

        state.config.sessionDrawIds = [...(state.config.sessionDrawIds || []), draw.id];
        await saveConfig();

        renderSessionWinners();

        $("savePrepare").classList.remove("hidden");

          state.spinning = false;
          updateDrawControls();

          setTimeout(() => $("projectionShell").classList.remove("hype"), 1200);
        } catch (error) {
          console.error("Error en sorteo:", error);
          state.spinning = false;
          $("start").disabled = false;
          $("start").textContent = "INICIAR SORTEO";
          $("winnerMain").textContent = "Error en el sorteo. Por favor intenta de nuevo.";
          $("projectionShell").classList.remove("hype");
          alert("Ocurri√≥ un error durante el sorteo: " + error.message);
        }
      }

      async function savePrepare() {
        try {
          // Detener confetti si est√° activo
          stopConfetti();

          await reqP(os(S.P, "readwrite").clear());

          state.participants = [];
          state.config.closed = false;
          state.config.closedAt = null;
          state.config.prize = "";
          state.config.excludeWinners = true;
          state.config.sessionDrawIds = [];
          state.spinning = false;

          $("prize").value = "";

          await saveConfig();

          // Limpiar clases de animaci√≥n
          $("projectionShell").classList.remove("hype");
          [...$("participantsGrid").children].forEach((box) => box.classList.remove("active", "winner"));

          renderParticipants();
          renderConfig();
          renderCountdown();

          fillGrid(winnerPool());
          renderSessionWinners();

          $("winnerMain").textContent = "Registro limpiado. Ajusta hora/premio para el siguiente sorteo.";
          $("start").disabled = false;
          $("start").textContent = "INICIAR SORTEO";

          $("savePrepare").classList.add("hidden");

          switchView("operator");
        } catch (error) {
          console.error("Error en savePrepare:", error);
          alert("Error al preparar nuevo sorteo: " + error.message);
        }
      }

      async function configureNextDrawForStart() {
        const mode = prompt("Escribe 'ahora' para ejecutar inmediato o HH:MM para nueva hora:", "ahora");
        if (!mode) return false;

        const newPrize = prompt("Valor del nuevo premio:", state.config.prize || "");
        if (newPrize === null) return false;

        state.config.prize = newPrize.trim();

        if (mode.toLowerCase() === "ahora") {
          state.config.closed = true;
          if (!state.config.closedAt) state.config.closedAt = nowISO();
        } else if (/^\d{2}:\d{2}$/.test(mode)) {
          state.config.time = mode;
          state.config.closed = false;
          state.config.closedAt = null;
        } else {
          alert("Formato invalido.");
          return false;
        }

        [...$("participantsGrid").children].forEach((box) => box.classList.remove("active", "winner"));

        await saveConfig();
        renderConfig();
        renderCountdown();

        fillGrid(winnerPool());
        renderSessionWinners();

        return true;
      }

      // ===== CONFETTI =====
      let confettiRAF = null;
      let confettiParts = [];

      function resizeConfettiCanvas() {
        const overlay = $("revealOverlay");
        const confettiCanvas = $("confetti");
        const rect = overlay.getBoundingClientRect();

        confettiCanvas.width = Math.max(1, Math.floor(rect.width));
        confettiCanvas.height = Math.max(1, Math.floor(rect.height));
      }

      function startConfetti() {
        resizeConfettiCanvas();

        const confettiCanvas = $("confetti");
        const cctx = confettiCanvas.getContext("2d");

        const colors = ['#FFD700', '#DC143C', '#0047AB', '#FFFFFF', '#DAA520', '#B91C1C', '#1e3a8a'];
        confettiParts = Array.from({ length: 180 }, () => ({
          x: Math.random() * confettiCanvas.width,
          y: -Math.random() * confettiCanvas.height,
          vy: 2 + Math.random() * 4,
          vx: -1 + Math.random() * 2,
          size: 4 + Math.random() * 6,
          rot: Math.random() * Math.PI,
          vr: -0.08 + Math.random() * 0.16,
          color: colors[Math.floor(Math.random() * colors.length)],
        }));

        function tick() {
          cctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);

          for (const p of confettiParts) {
            p.x += p.vx;
            p.y += p.vy;
            p.rot += p.vr;

            if (p.y > confettiCanvas.height + 20) {
              p.y = -20;
              p.x = Math.random() * confettiCanvas.width;
            }

            if (p.x < -20) p.x = confettiCanvas.width + 20;
            if (p.x > confettiCanvas.width + 20) p.x = -20;

            cctx.save();
            cctx.translate(p.x, p.y);
            cctx.rotate(p.rot);
            cctx.fillStyle = p.color;
            cctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
            cctx.restore();
          }

          confettiRAF = requestAnimationFrame(tick);
        }

        confettiRAF = requestAnimationFrame(tick);

        window.addEventListener("resize", resizeConfettiCanvas, { passive: true });
      }

      function stopConfetti() {
        if (confettiRAF) cancelAnimationFrame(confettiRAF);

        confettiRAF = null;
        confettiParts = [];

        const confettiCanvas = $("confetti");
        const cctx = confettiCanvas.getContext("2d");
        cctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);

        window.removeEventListener("resize", resizeConfettiCanvas);
      }

      function revealWinner(name, prize) {
        const overlay = $("revealOverlay");
        const card = $("revealCard");

        const formattedPrize = formatPrize(prize || state.config.prize);

        card.innerHTML = `
          <div style="font-size:0.35em;opacity:0.95;margin-bottom:12px;letter-spacing:2px">üèÜ GANADOR üèÜ</div>
          ${safeText(name)}
          <div style="font-size:0.32em;margin-top:15px;opacity:0.9;background:rgba(0,0,0,0.3);padding:8px 16px;border-radius:10px">
            ${safeText(formattedPrize || "Premio no especificado")}
          </div>
        `;

        overlay.classList.add("show");
        startConfetti();
        ding();

        setTimeout(() => {
          overlay.classList.remove("show");
          setTimeout(() => stopConfetti(), 400);
        }, 3500);
      }

      // ===== EXPORT =====
      function dl(name, text, type) {
        const b = new Blob([text], { type });
        const a = document.createElement("a");

        a.href = URL.createObjectURL(b);
        a.download = name;
        a.click();

        URL.revokeObjectURL(a.href);
      }

      function exportJSON() {
        const file = `historial_${new Date().toISOString().slice(0, 10)}.json`;
        const payload = JSON.stringify(
          {
            exportedAt: nowISO(),
            config: state.config,
            participants: state.participants,
            draws: state.draws,
          },
          null,
          2
        );

        dl(file, payload, "application/json");
      }

      function exportCSV() {
        const h = [
          "id",
          "fecha",
          "hora",
          "titulo",
          "premio",
          "ganador",
          "cierre_registro",
          "total_participantes",
          "excluir_ganadores",
          "pagado",
          "fecha_pago",
        ];

        const esc = (s) => {
          s = String(s ?? "");
          return /[,"\n]/.test(s) ? `"${s.replace(/"/g, '""')}"` : s;
        };

        const rows = state.draws.map((d) => [
          d.id,
          fmtLong(new Date(d.drawAt)),
          d.time,
          d.title,
          d.prize,
          d.winnerName,
          d.closedAt,
          d.participantCount,
          d.excludeWinners ? "si" : "no",
          d.paid ? "si" : "no",
          d.paid ? fmtPayment(new Date(d.paidAt)) : "",
        ]);

        const file = `historial_${new Date().toISOString().slice(0, 10)}.csv`;
        const csv = [h.join(","), ...rows.map((r) => r.map(esc).join(","))].join("\n");

        dl(file, csv, "text/csv");
      }

      // ===== PAGO =====
      async function registerPayment(drawId) {
        if (!confirm("¬øConfirmar que se ha pagado este premio?")) return;

        const draw = state.draws.find((d) => d.id === drawId);

        if (!draw) {
          alert("Sorteo no encontrado.");
          return;
        }

        if (draw.paid) {
          alert("Este sorteo ya est√° marcado como pagado.");
          return;
        }

        draw.paid = true;
        draw.paidAt = nowISO();

        await reqP(os(S.D, "readwrite").put(draw));

        renderHistory();
        alert("Pago registrado exitosamente.");
      }

      // ===== BORRAR TODO =====
      async function clearAllData() {
        const pass = prompt("Ingresa la contrasena para borrar todos los datos:");

        if (pass !== "1980") {
          alert("Contrasena incorrecta.");
          return;
        }

        if (!confirm("Se eliminaran participantes, sorteos e historial. Esta accion no se puede deshacer. Continuar?"))
          return;

        try {
          // Detener confetti si est√° activo
          stopConfetti();

          // Limpiar IndexedDB
          await reqP(os(S.P, "readwrite").clear());
          await reqP(os(S.D, "readwrite").clear());
          await reqP(os(S.K, "readwrite").clear());

          // Resetear estado completo
          state.participants = [];
          state.draws = [];
          state.knownClients = [];
          state.spinning = false;
          state.soundOn = true;

          state.config = {
            title: "",
            time: "",
            closed: false,
            closedAt: null,
            prize: "",
            excludeWinners: true,
            sessionDrawIds: [],
          };

          await saveConfig();

          // Limpiar clases de animaci√≥n
          $("projectionShell").classList.remove("hype");
          [...$("participantsGrid").children].forEach((box) => {
            box.classList.remove("active", "winner");
          });

          // Re-renderizar todo
          renderParticipants();
          renderHistory();
          renderKnownClients();
          renderConfig();
          renderCountdown();

          fillGrid(winnerPool());
          renderSessionWinners();

          // Resetear botones y mensajes
          $("start").disabled = false;
          $("start").textContent = "INICIAR SORTEO";
          $("savePrepare").classList.add("hidden");
          $("winnerMain").textContent = "Datos borrados. Pulsa INICIAR SORTEO";

          alert("Datos eliminados correctamente.");
        } catch (error) {
          console.error("Error limpiando datos:", error);
          alert("Error al limpiar los datos: " + error.message);
        }
      }

      // ===== CONTROLES =====
      function updateDrawControls() {
        const done = (state.config.sessionDrawIds || []).length;
        const startBtn = $("start");

        if (!startBtn) return;
        if (state.spinning) return;

        startBtn.disabled = done >= 3;
        startBtn.textContent = "INICIAR SORTEO";
      }

      function switchView(v) {
        $("operatorView").classList.toggle("hidden", v !== "operator");
        $("projectionView").classList.toggle("hidden", v === "operator");
      }

      async function registerSW() {
        if ("serviceWorker" in navigator) {
          try {
            await navigator.serviceWorker.register("./sw.js");
          } catch (_) {}
        }
      }

      // ===== RESETEO DE EMERGENCIA =====
      async function emergencyReset() {
        console.log("üö® INICIANDO RESETEO DE EMERGENCIA...");

        try {
          // Cerrar todas las conexiones de IndexedDB
          if (db) {
            db.close();
            db = null;
          }

          // Eliminar la base de datos completamente
          const deleteRequest = indexedDB.deleteDatabase(DB_NAME);
          await new Promise((resolve, reject) => {
            deleteRequest.onsuccess = resolve;
            deleteRequest.onerror = reject;
          });

          console.log("‚úÖ Base de datos eliminada");

          // Resetear estado en memoria
          state.participants = [];
          state.draws = [];
          state.knownClients = [];
          state.spinning = false;
          state.soundOn = true;
          state.config = {
            title: "",
            time: "",
            closed: false,
            closedAt: null,
            prize: "",
            excludeWinners: true,
            sessionDrawIds: [],
          };

          console.log("‚úÖ Estado reseteado");

          // Detener confetti
          stopConfetti();

          // Limpiar animaciones
          $("projectionShell").classList.remove("hype");
          [...$("participantsGrid").children].forEach((box) => {
            box.classList.remove("active", "winner");
          });

          // Reiniciar base de datos
          db = await openDB();
          await saveConfig();

          console.log("‚úÖ Base de datos recreada");

          // Re-renderizar todo
          renderParticipants();
          renderHistory();
          renderKnownClients();
          renderConfig();
          renderCountdown();
          fillGrid(winnerPool());
          renderSessionWinners();

          // Resetear controles
          $("start").disabled = false;
          $("start").textContent = "INICIAR SORTEO";
          $("savePrepare").classList.add("hidden");
          $("winnerMain").textContent = "Sistema reseteado. Pulsa INICIAR SORTEO";
          $("name").disabled = false;
          $("register").disabled = false;

          console.log("‚úÖ RESETEO COMPLETADO");
          alert("‚úÖ Sistema reseteado completamente. Ya puedes registrar participantes.");
          return true;
        } catch (error) {
          console.error("‚ùå Error en reseteo de emergencia:", error);
          alert("Error en reseteo: " + error.message + "\n\nRecarga la p√°gina (F5) y vuelve a intentar.");
          return false;
        }
      }

      // Funci√≥n de diagn√≥stico
      function diagnostico() {
        console.log("üìä DIAGN√ìSTICO DEL SISTEMA");
        console.log("==========================");
        console.log("Estado actual:", {
          participantes: state.participants.length,
          sorteos: state.draws.length,
          spinning: state.spinning,
          config: state.config,
        });
        console.log("\nüîç Verificaciones:");
        console.log("- Registro cerrado:", state.config.closed);
        console.log("- Hora configurada:", state.config.time);
        console.log("- Cerrado por tiempo:", closedByTime());
        console.log("- Bot√≥n registro deshabilitado:", $("register").disabled);
        console.log("- Bot√≥n sorteo deshabilitado:", $("start").disabled);
        console.log("\nüí° Soluci√≥n:");
        console.log("Si el registro est√° bloqueado, ejecuta: emergencyReset()");
        return state;
      }

      // Exponer funciones globalmente
      window.emergencyReset = emergencyReset;
      window.diagnostico = diagnostico;
      window.appState = state; // Para inspecci√≥n directa

      // ===== PANTALLA COMPLETA =====
      function toggleFullscreen() {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen().catch((err) => {
            console.log("Error al entrar en pantalla completa:", err);
          });
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          }
        }
      }

      // Listener para ESC (salir de pantalla completa)
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && document.fullscreenElement) {
          document.exitFullscreen();
        }
      });

      // Listener para cambio de estado de pantalla completa
      document.addEventListener("fullscreenchange", () => {
        const btn = $("fullscreenBtn");
        if (btn) {
          btn.textContent = document.fullscreenElement ? "‚õ∂" : "‚õ∂";
          btn.title = document.fullscreenElement
            ? "Salir de pantalla completa (ESC)"
            : "Pantalla completa (F11 o clic)";
        }
      });

      function bind() {
        $("register").onclick = registerParticipant;
        $("saveConfig").onclick = saveCfg;
        $("closeNow").onclick = closeNow;

        $("toProjection").onclick = async () => {
          state.config.prize = $("prize").value.trim();
          await saveConfig();
          renderConfig();
          switchView("projection");
        };

        $("start").onclick = startDraw;
        $("savePrepare").onclick = savePrepare;

        $("goOperator").onclick = () => switchView("operator");
        $("goProjection").onclick = () => switchView("projection");

        // Bot√≥n de pantalla completa
        $("fullscreenBtn").onclick = toggleFullscreen;

        $("exportJson").onclick = exportJSON;
        $("exportCsv").onclick = exportCSV;

        $("clearData").onclick = clearAllData;

        $("name").addEventListener("keydown", (e) => {
          if (e.key !== "Enter") return;

          e.preventDefault();

          const typed = $("name").value.trim();
          if (!typed) return registerParticipant();

          const exact = state.knownClients.find((c) => norm(c.name) === norm(typed));
          if (exact) return registerParticipant();

          const match = state.knownClients.find((c) => norm(c.name).startsWith(norm(typed)));
          if (match) {
            $("name").value = match.name;
            showMsg("regMsg", `Autocompletado: ${match.name}. Presiona ENTER de nuevo para registrar.`, "ok");
            return;
          }

          registerParticipant();
        });

        $("applyNameFix").onclick = applyNameCorrection;

        $("drawTitle").oninput = (e) => {
          state.config.title = e.target.value;
          $("pTitle").textContent = state.config.title || "Sorteo en Vivo";
        };

        $("drawTime").oninput = (e) => {
          state.config.time = e.target.value;
          renderCountdown();
        };

        $("prize").oninput = async (e) => {
          state.config.prize = e.target.value;
          await saveConfig();
          $("pPrize").textContent = state.config.prize
            ? `Premio: ${formatPrize(state.config.prize)}`
            : "Premio: --";
        };

        setInterval(async () => {
          let changed = false;

          if (!state.config.closed && closedByTime()) {
            state.config.closed = true;
            state.config.closedAt = nowISO();
            await saveConfig();
            changed = true;
          }

          if (changed) renderConfig();
          renderCountdown();
        }, 1000);
      }

      (async function init() {
        try {
          db = await openDB();
          await load();

          if (!Array.isArray(state.config.sessionDrawIds)) state.config.sessionDrawIds = [];

          renderParticipants();
          renderHistory();
          renderKnownClients();

          renderConfig();
          renderCountdown();

          fillGrid(winnerPool());
          renderSessionWinners();

          initParticles();
          animateParticles();

          bind();
          await registerSW();
        } catch (e) {
          alert("Error al iniciar app: " + e.message);
        }
      })();
    </script>
  </body>
</html>